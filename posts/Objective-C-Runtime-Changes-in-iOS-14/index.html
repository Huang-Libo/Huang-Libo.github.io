<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="layout-lang" content="zh-CN"><meta name="day-prompt" content="d ago"><meta name="hour-prompt" content="hr ago"><meta name="minute-prompt" content="min ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="【iOS 14】Objective-C Runtime 的优化" /><meta name="author" content="BOB" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="目录" /><meta property="og:description" content="目录" /><link rel="canonical" href="https://huang-libo.github.io/posts/Objective-C-Runtime-Changes-in-iOS-14/" /><meta property="og:url" content="https://huang-libo.github.io/posts/Objective-C-Runtime-Changes-in-iOS-14/" /><meta property="og:site_name" content="BOB’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-05-17T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="【iOS 14】Objective-C Runtime 的优化" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@BOB" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"BOB"},"description":"目录","url":"https://huang-libo.github.io/posts/Objective-C-Runtime-Changes-in-iOS-14/","@type":"BlogPosting","headline":"【iOS 14】Objective-C Runtime 的优化","dateModified":"2021-10-20T14:00:26+08:00","datePublished":"2021-05-17T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://huang-libo.github.io/posts/Objective-C-Runtime-Changes-in-iOS-14/"},"@context":"https://schema.org"}</script><title>【iOS 14】Objective-C Runtime 的优化 | BOB's blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="BOB's blog"><meta name="application-name" content="BOB's blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang=""><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/favicon.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">BOB's blog</a></div><div class="site-subtitle font-italic">Just for Fun!</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/Huang-Libo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['LiboHwang+IM','gmail.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-5" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>【iOS 14】Objective-C Runtime 的优化</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>【iOS 14】Objective-C Runtime 的优化</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Huang Libo </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, May 17, 2021, 12:00 AM +0800" >May 17<i class="unloaded">2021-05-17T00:00:00+08:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Oct 20, 2021, 2:00 PM +0800" >Oct 20<i class="unloaded">2021-10-20T14:00:26+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5866 words">32 minread</span></div></div><div class="post-content"><p><h2>目录</h2></p><ul><li><a href="#前言">前言</a><li><a href="#新特性的适配">新特性的适配</a><li><a href="#1-新增类型class_rw_ext_t">1. 新增类型：class_rw_ext_t</a><ul><li><a href="#class_ro_t">class_ro_t</a><li><a href="#clean-memory--dirty-memory">Clean memory &amp; Dirty memory</a><li><a href="#class_rw_t">class_rw_t</a><li><a href="#从-class_rw_t-中拆分出-class_rw_ext_t">从 class_rw_t 中拆分出 class_rw_ext_t</a><li><a href="#实例">实例</a><ul><li><a href="#macos-的-mail">macOS 的 Mail</a><li><a href="#macos-版的-wechat">macOS 版的 WeChat</a></ul><li><a href="#使用-runtime-apis">使用 Runtime APIs</a></ul><li><a href="#2-相对方法列表-reletive-method-lists-">2. 相对方法列表（ Reletive Method Lists ）</a><ul><li><a href="#objective-c-方法的-3-个部分">Objective-C 方法的 3 个部分</a><li><a href="#以-init-方法为例">以 init 方法为例</a><li><a href="#进程中内存的划分">进程中内存的划分</a><li><a href="#使用普通的方法列表-method-lists-">使用普通的方法列表 (Method Lists )</a><li><a href="#使用相对方法列表-reletive-method-lists-">使用相对方法列表 (Reletive Method Lists )</a><li><a href="#swizzling-relative-method-lists">Swizzling relative method lists</a><li><a href="#deployment-target">Deployment target</a><li><a href="#mismatched-deployment-targets">Mismatched deployment targets</a><li><a href="#使用-runtime-apis-1">使用 Runtime APIs</a></ul><li><a href="#3-arm64-架构上-tagged-pointer-格式的变化">3. ARM64 架构上 Tagged Pointer 格式的变化</a><ul><li><a href="#普通的对象指针">普通的对象指针</a><li><a href="#intel">Intel</a><ul><li><a href="#混淆-tagged-pointer-的值">混淆 tagged pointer 的值</a><li><a href="#tag-number-和-payload">tag number 和 payload</a><li><a href="#extended-tag">extended tag</a><li><a href="#swift-中的-tagged-pointer">Swift 中的 tagged pointer</a></ul><li><a href="#arm64">ARM64</a><ul><li><a href="#ios-13-中-tagged-pointer-的格式">iOS 13 中 tagged pointer 的格式</a><li><a href="#ios-14-中-tagged-pointer-格式的变化">iOS 14 中 tagged pointer 格式的变化</a></ul><li><a href="#使用-apis">使用 APIs</a></ul><li><a href="#小结">小结</a><ul><li><a href="#相关资料">相关资料</a></ul><li><a href="#reference">Reference</a></ul><h2 id="前言">前言</h2><p><a href="https://developer.apple.com/videos/play/wwdc2020/10163/">WWDC 2020 / 10163 - Advancements in the Objective-C runtime</a> 介绍了 <em>2020</em> 年 <em>Objective-C Runtime</em> 的一些优化，演讲者来自 <em>Languages and Runtimes Team</em> 。内容包含：</p><ol><li><em>Class Data Structure</em> 的优化：从 <code class="language-plaintext highlighter-rouge">class_rw_t</code> 中拆分出一个名为 <code class="language-plaintext highlighter-rouge">class_rw_ext_t</code> 的新类型；<li>在<em>二进制映像 (Binary Image)</em> 中使用<strong>相对方法列表 (Reletive Method Lists)</strong> ；<li><em>ARM64</em> 架构上 <strong>Tagged Pointer</strong> 格式的变化。</ol><p>经过优化后：</p><ul><li><em>Better performance and lower memory usage</em>（更好的性能和更少的内存使用）<li><em>Smaller binaries</em>（二进制包更小）<li><em>ARM64</em> 架构上的 <em>Tagged Pointer</em> 可以存放普通的<em>对象指针</em>了。</ul><p>由于疫情影响，<em>WWDC 2020</em> 完全是线上举办的，官网上也没有给出演示 <em>PDF</em> ，只有<a href="https://github.com/Bob-Playground/WWDC-Stuff/blob/master/2020/10163-OC-Runtime-Changes/Transcript-Edited.md">讲稿（即字幕）</a>。</p><h2 id="新特性的适配">新特性的适配</h2><blockquote><p>With any luck, you won’t need to do anything and your apps will just get faster.</p></blockquote><p>“运气好的话，你不需要做任何事情，你的应用程序就会变得更快。”</p><p>如果代码中没有依赖“隐藏”在 Runtime 中的<em>内部类型 (internal data structures)</em> ，比如 <code class="language-plaintext highlighter-rouge">class_rw_t</code>，或直接读取 <em>Tagged Pointer</em> 的 <em>bit</em> 数据，那就不需要做改动。</p><p>但如果 App 中直接使用了这些“隐藏”的内容，App 在新系统上可能会出现异常。</p><p>这些优化将在下列系统中生效：</p><ul><li><em>macOS Big Sur (macOS 11)</em><li><em>iOS 14</em><li><em>tvOS 14</em><li><em>watchOS 7</em></ul><h2 id="1-新增类型class_rw_ext_t">1. 新增类型：class_rw_ext_t</h2><blockquote><p>在 <em>iOS 14</em> 的 <em>Class Data Structure</em> 中新增了 <code class="language-plaintext highlighter-rouge">class_rw_ext_t</code> 类型。</p></blockquote><p>我们先看看 <em>iOS 13</em> 的 Runtime 是如何运行的。</p><h3 id="class_ro_t">class_ro_t</h3><p>类对象 (<em>class object</em>) 中包含了我们最常访问的信息：指向元类的指针 (<em>metaclass</em>) ，指向父类的指针 (<em>superclass</em>) ，以及指向方法缓存的指针 (<em>method cache</em>) 。</p><p>类对象中还有一个 <code class="language-plaintext highlighter-rouge">class_ro_t</code> 类型的指针，指向存有更多信息的类型。其中的 <strong>ro</strong> 代表 <strong>read only</strong> 。<code class="language-plaintext highlighter-rouge">class_ro_t</code> 存储着<strong>类的名称</strong>，以及<strong>方法列表</strong>、<strong>协议</strong>、<strong>属性</strong>、<strong>实例变量</strong>等信息。</p><p><em>类对象</em>和 <code class="language-plaintext highlighter-rouge">class_ro_t</code> 的示意图：</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-class_ro_t.jpg" alt="runtime-class_ro_t.jpg" /></p><p><em>Swift 类</em> 和 <em>Objective-C 类</em> 共用这个基础设施 (<em>infrastructure</em>) ，因此每个 <em>Swift 类</em> 也有这些结构。</p><p>当<em>类</em>第一次从 <em>disk</em> 加载到 <em>memory</em> 时，他们就是以这种方式呈现的，但是当<em>类</em>被<strong>使用</strong>时会发生改变。</p><h3 id="clean-memory--dirty-memory">Clean memory &amp; Dirty memory</h3><p>为了理解后续要发生的事，需要了解 <em>clean memory</em> 和 <em>dirty memory</em> 的区别。</p><dl><dt>Clean Memory<dd><em>Clean memory</em> 是加载后就不会改变的 <em>memory</em> ，比如 <code class="language-plaintext highlighter-rouge">class_ro_t</code> ，因为它是 <em>read only</em> 的。<dd><em>Clean memory</em> 可以从 <em>memory</em> 中清除、为其他内容腾出空间。因为如果需要它，系统总是可以从 <em>disk</em> 重新加载它。<dt>Dirty Memory<dd><em>Dirty memory</em> 是当<em>进程</em>运行的时候会被改变的 <em>memory</em> ，比如<em>类对象</em>。因为 Runtime 会为<em>类对象</em>创建一个全新的 <em>method cache</em> ，并让<em>类对象</em>内的一个指针指向 <em>method cache</em> 。<dd><em>Dirty memory</em> 比 <em>Clean memory</em> 昂贵得多。它必须在<em>进程</em>运行期间一直存在。</dl><p><em>macOS</em> 可以把 <em>memory</em> 内的 <em>Dirty Memory</em> 转移至 <em>swap（交换分区）；而</em> <em>iOS</em> 不使用 <em>swap</em> ，所以在 <em>iOS</em> 中 <em>Dirty Memory</em> 很昂贵。</p><h3 id="class_rw_t">class_rw_t</h3><p>当<em>类</em><strong>第一次使用时</strong>，Runtime 创建了一个额外的类型，叫做 <code class="language-plaintext highlighter-rouge">class_rw_t</code> ，<strong>rw</strong> 代表 <strong>read/write</strong>（可读可写）。</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-class_rw_t.jpg" alt="runtime-class_rw_t.jpg" /> <em>绿色部分是 dirty memory ，蓝色部分是 clean memory</em></p><p>在 <code class="language-plaintext highlighter-rouge">class_rw_t</code> 中，存储着在 Runtime 期间生成的信息。</p><p>例如，所有<em>类</em>都使用 <em>First Subclass</em> 和 <em>Next Sibling Class</em> 指针链接到一个树结构中，这允许 Runtime 遍历当前使用的所有类，这对于使方法缓存失效是很有用的。（<strong>这个地方的细节不太了解，作者也没细讲，待研究</strong>）</p><p><code class="language-plaintext highlighter-rouge">class_ro_t</code> 中已经有了 <strong>方法列表</strong>、<strong>协议</strong>、<strong>属性</strong> ，为什么又在新创建的 <code class="language-plaintext highlighter-rouge">class_rw_t</code> 中添加它们呢？</p><p>原因是它们可以在运行时被改变。</p><p>比如，当一个分类被加载时，它可以向原类中添加新方法。即程序员可以使用 <em>Runtime API</em> 动态地添加它们。</p><h3 id="从-class_rw_t-中拆分出-class_rw_ext_t">从 class_rw_t 中拆分出 class_rw_ext_t</h3><blockquote><p>We measured about 30 megabytes of these class_rw_t structures across the system on an iPhone.</p></blockquote><p>“我们在 <em>iPhone</em> 系统中检测到了大约 <strong>30MB</strong> 的 <code class="language-plaintext highlighter-rouge">class_rw_t</code> 结构。”</p><p>由于 <code class="language-plaintext highlighter-rouge">class_rw_t</code> 在运行时会被改变，因此它是 <em>dirty memory</em> 。在我们的设备上有很多<em>类</em>在被使用中，它们占用了相当多的内存。</p><p>那我们怎样把它们缩小呢？</p><p>还记得吗，我们之所以在“读/写部分”需要这些东西，是因为它们可以在<em>运行时</em>更改。</p><blockquote><p>But examining usage on real devices, we found that only around 10% of classes ever actually have their methods changed.</p></blockquote><p>“但是通过对实际设备的使用进行分析，我们发现只有大约 <strong>10%</strong> 的<em>类</em>真正改变了它们的<strong>方法列表</strong> 。”</p><p>并且 <code class="language-plaintext highlighter-rouge">demangled</code> 只被 <em>Swift class</em> 使用了，并且只有当 <em>Swift class</em> 查询它们对应的 Objective-C 名称时，才需要用到它。</p><p>因此，我们可以把 <code class="language-plaintext highlighter-rouge">class_rw_t</code> 拆成两部分，将不常使用的部分拆分出去、放在名为 <code class="language-plaintext highlighter-rouge">class_rw_ext_t</code> 的新结构中。</p><p>对于确实需要<em>附加信息</em>的<em>类</em>，我们才创建 <code class="language-plaintext highlighter-rouge">class_rw_ext_t</code> 。</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-class_rw_ext_t-1.jpg" alt="runtime-class_rw_ext_t-1.jpg" /></p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-class_rw_ext_t-2.jpg" alt="runtime-class_rw_ext_t-2.jpg" /></p><blockquote><p>Approximately 90% of classes never need this extended data, saving around 14 megabytes system wide.</p></blockquote><p>“大约 90% 的类从不需要这种扩展数据，在系统范围内节省了大约 <strong>14MB</strong> 内存。”</p><h3 id="实例">实例</h3><p>使用 <code class="language-plaintext highlighter-rouge">heap</code> 命令查看 <em>macOS Big Sur</em> 应用中 <code class="language-plaintext highlighter-rouge">class_rw_t</code> 和 <code class="language-plaintext highlighter-rouge">class_rw_ext_t</code> 的使用情况。</p><h4 id="macos-的-mail">macOS 的 Mail</h4><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>heap Mail | egrep <span class="s1">'class_rw|COUNT'</span>
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-class_rw_ext_t-heap-Mail.jpg" alt="runtime-class_rw_ext_t-heap-Mail.jpg" /></p><p><em>Mail</em> 中只有约 <strong>10%</strong> 的类使用了 <code class="language-plaintext highlighter-rouge">class_rw_ext_t</code> 。</p><h4 id="macos-版的-wechat">macOS 版的 WeChat</h4><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>heap WeChat | egrep <span class="s1">'class_rw|COUNT'</span>
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-class_rw_ext_t-heap-WeChat.jpg" alt="runtime-class_rw_ext_t-heap-WeChat.jpg" /></p><p><em>WeChat</em> 中只有约 <strong>8%</strong> 的类使用了 <code class="language-plaintext highlighter-rouge">class_rw_ext_t</code> 。</p><h3 id="使用-runtime-apis">使用 Runtime APIs</h3><p>我们应该使用 Runtime 的公开 API ，Apple 保障它们的稳定性。比如：</p><ul><li><code class="language-plaintext highlighter-rouge">class_getName</code><li><code class="language-plaintext highlighter-rouge">class_getSuperclass</code><li><code class="language-plaintext highlighter-rouge">class_copyMethodList</code><li>…</ul><p>而不要在代码中直接使用 Runtime 的这些私有类型，否则，如果新系统更新了这些类型的 <em>layout</em>，代码就无法正常运行了。</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-class_rw_ext_t-error.jpg" alt="runtime-class_rw_ext_t-error.jpg" /></p><p>比如，代码直接去 <code class="language-plaintext highlighter-rouge">class_rw_t</code> 中读取 <em>Methods</em> ，在 <em>iOS 13</em> 上是可行的，但在 <em>iOS 14</em> 上 <code class="language-plaintext highlighter-rouge">class_rw_t</code> 中已经没有了 <em>Methods</em> ，它被挪动到了 <code class="language-plaintext highlighter-rouge">class_rw_ext_t</code> 中。</p><h2 id="2-相对方法列表-reletive-method-lists-">2. 相对方法列表（ Reletive Method Lists ）</h2><blockquote><p>在 <em>Binary Image</em> 中使用 <strong>Reletive Method Lists</strong> 。</p></blockquote><p>每个<em>类</em>都有一个附属的<em>方法列表 (Method List)</em> 。当你给一个<em>类</em>写了一个新方法，它会被添加到这个列表中。</p><p>Runtime 使用<em>方法列表</em>来解析<em>消息发送 (message sends)</em> 。</p><h3 id="objective-c-方法的-3-个部分">Objective-C 方法的 3 个部分</h3><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-method-list.jpg" alt="runtime-method-list.jpg" /> <em>每个 Objective-C 方法都由 3 个部分构成</em></p><dl><dt>method’s name<dd>也称之为 <em>selector</em> ，对应 <code class="language-plaintext highlighter-rouge">SEL</code> 类型。<em>selector</em> 就是<em>字符串 (Strings)</em> ，但是它们是唯一的，所以可以通过<em>指针</em>检测是否相同。<dt>method’s type encoding<dd>是 <code class="language-plaintext highlighter-rouge">char *</code> 类型的，表示<em>参数 (parameters)</em> 和<em>返回值 (return types)</em> 的类型。它不用于<em>消息发送 (message sends )</em>，但 Runtime <em>内省 (introspection)</em> 和消息转发 (<em>message forwarding</em> )等事情需要它。<dt>method’s implementation<dd>对应 <code class="language-plaintext highlighter-rouge">IMP</code> 类型，表示一个指向<em>方法实现</em>的指针 (<em>the actual code for the method</em>) 。我们编写的 Objective-C 方法会被编译成 C 函数，它包含 Objective-C 方法的实现，然后<em>方法列表</em>中的相应条目指向这个函数。</dl><h3 id="以-init-方法为例">以 init 方法为例</h3><p><em>方法列表</em>中的这 3 项内容都是<em>指针</em>类型。</p><p>这意味着在<strong>64位</strong>系统中，<em>方法列表</em>中每一个方法的信息占用<strong>24字节</strong>：</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-method-pointer-size-64bit.jpg" alt="Desktop View" class="normal" width="400" /></p><h3 id="进程中内存的划分">进程中内存的划分</h3><p>上述内容属于 <em>clean memory</em> ，但 <em>clean memory</em> 也不是“免费”的。它仍然需要从 <em>disk</em> 加载，并在使用时占用 <em>memory</em> 。</p><p>这是进程中<em>内存</em>的放大视图：</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-normal-binary-images-in-memory.jpg" alt="runtime-normal-binary-images-in-memory.jpg" class="normal" width="200" /></p><p>这个地址空间很大，需要使用<strong>64位</strong>来寻址。在这个地址空间中，内存被划分成了多个部分：</p><ul><li><em>栈 (stack )</em><li><em>堆 (heap )</em><li><em>可执行程序 (executables )</em><li>加载到进程中的<em>库 (libraries )</em>或<em>二进制映象 (binary images)</em> (上图<strong>蓝色</strong>部分)</ul><h3 id="使用普通的方法列表-method-lists-">使用普通的方法列表 (Method Lists )</h3><p>仍以 <code class="language-plaintext highlighter-rouge">init</code> 方法为例，我们放大来看其中一个 <em>binary image</em> ：</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-normal-method-list.jpg" alt="runtime-normal-method-list.jpg" /></p><p>我们可以看到，方法列表中的 3 个指针指向了<em>二进制文件</em>中的地址。这给我们展现了额外的消耗：</p><ul><li>一个 <em>binary image</em> 可以被加载到 <em>memory</em> 的任何地方，具体加载到哪由<em>动态链接器(dynamic linker)</em> 决定。<li>这意味着<em>动态链接器</em>需要解析指向 <em>binary image</em> 的指针，并且在加载 <em>binary image</em> 的时候将指针修改为<em>方法信息</em>在内存中的实际地址。这也消耗性能。</ul><p>但是请注意，<em>binary image</em> 中的<em>类</em>的 <em>method entry</em> ，只会指向该 <em>binary image</em> 中的方法的实现。我们不会把某方法的 metadata 放在一个 binary 中，而把这个方法的实现放在另一个 binary 中。</p><p>这意味着 <em>method list entries</em> 实际上不需要引用整个<strong>64位</strong>地址空间的能力。它们只需要能够引用自己的 <em>binary image</em> 中的方法，而这些方法总是在附近。</p><h3 id="使用相对方法列表-reletive-method-lists-">使用相对方法列表 (Reletive Method Lists )</h3><p>因此，<em>method list entries</em> 可以在 <em>binary image</em> 中使用<strong>32位</strong>的<em>相对偏移量 (relative offset)</em> ，而不是<strong>64位</strong>的<em>绝对地址</em>：</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-relative-method-list.jpg" alt="runtime-relative-method-list.jpg" /></p><p>这种方案有几个优势：</p><ul><li>首先，无论 <em>binary image</em> 被加载到<em>内存</em>的哪个位置，<em>偏移量</em>总是相同的，所以它们不必在从<em>磁盘</em>加载后进行修正。<li>因为它们不需要被修正，它们可以被保存在真正的<em>只读内存</em>中，这是更安全的。<li>使用<strong>32位</strong>的<em>偏移地址</em>意味着我们在<strong>64位</strong>平台上<strong>需要的内存减少了一半</strong>。</ul><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-method-pointer-size-32bit.jpg" alt="runtime-method-pointer-size-32bit.jpg" class="normal" width="400" /></p><p>现在<em>方法列表</em>中的每一个方法的信息只占用<strong>12字节</strong>。</p><blockquote><p>We’ve measured about 80MB of these methods system wide on a typical iPhone. Since they’re half the size, we save 40 megabytes.</p></blockquote><p>“我们在一个典型的 <em>iPhone</em> 做了测量，在系统范围内的这些方法大约占用了 <strong>80MB</strong> 。由于我们将它们减半了，所以节省了 <strong>40MB</strong> 。”</p><p>为了体现出优化效果明显，PPT 里还播放了一个震撼的动画。和其他厂的宣传 PPT 不同的是，这个没有搭配震撼的音效 [手动狗头]：</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-relative-method-list-saving-memory.jpg" alt="runtime-relative-method-list-saving-memory.jpg" class="normal" width="500" /></p><h3 id="swizzling-relative-method-lists">Swizzling relative method lists</h3><p>使用了<em>相对方法列表</em>后，就不能使用完整的地址空间了。但是如果对一个方法做了 <em>Swizzling</em> ，那么这个方法的实现将会出现在任何地方。而且刚才我们提到要把 <em>binary image</em> 的<em>方法列表</em>设置为<em>只读</em>的。</p><p>为了处理这种场景，<em>iOS 14</em> 的 Runtime 使用了一个<em>全局表 (global table)</em> 映射<em>方法</em>到它们的 <em>Swizzling</em> <em>实现</em>。</p><p>实际上，<em>Swizzling</em> 很少。绝大多数<em>方法</em>实际上从来没有被 <em>Swizzling</em> ，所以这个 <em>table</em> 最终不会变得很大。</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-relative-method-list-swizzling.jpg" alt="runtime-relative-method-list-swizzling.jpg" /></p><blockquote><p>Even better, the table is compact. Memory is dirtied a page at a time.</p></blockquote><p>更好的是，这个 <em>table</em> 很小巧。每次只“污染”内存的一<em>页 (page)</em> 。</p><ul><li>在使用旧格式的<em>方法列表</em>时，<em>Swizzling</em> 一个方法会污染<em>它所在的全部页 (entire page)</em> ，一次 <em>Swizzling</em> 会导致<em>很多 KB (kilobytes)</em> 的脏内存。<li>在使用 <em>global table</em> 后，我们只需要付出一个额外的<em>表条目 (table entry)</em> 的成本。</ul><h3 id="deployment-target">Deployment target</h3><p>如果使用相符的 <em>minimum deployment target</em> （至少 <em>iOS 14</em>）构建项目，那么 <em>Xcode</em> 会自动为构建的二进制包生成 <em>relative method lists</em> 。</p><p>如果需要支持旧的系统版本，<em>Xcode</em> 会生成旧风格的 <em>method list</em> 。</p><blockquote><p>You still get the benefit from the OS itself being built with the new relative method lists, and the system has no problem with both formats in use in the same app at the same time.</p></blockquote><p>“你仍然可以从使用新的 <em>relative method lists</em> 构建的操作系统中获得好处，并且系统在同一 App 中同时使用两种格式没有问题。”</p><p>比如，假设我们的 App 的 <em>minimum deployment target</em> 指定的是 <em>iOS 13</em> ，并在 App 内引入了两个库：</p><ol><li>系统内建的 <code class="language-plaintext highlighter-rouge">UIKit</code> ，它在 <em>iOS 13</em> 上使用的是普通方法列表，在 <em>iOS 14</em> 的 <code class="language-plaintext highlighter-rouge">UIKit</code> 使用的是相对方法列表；<li>一个第三方的 <em>Framework</em> ，<em>minimum deployment target</em> 指定的是 <em>iOS 13</em> ，因此它将使用普通方法列表。</ol><p>在 <em>iOS 14</em> 系统上运行这个 App ，使用相对方法列表的 <code class="language-plaintext highlighter-rouge">UIKit</code> 和使用普通方法列表的 <em>Framework</em> 都能正常运行。</p><p>但是，如果把项目的 <em>minimum deployment target</em> 指定为今年发布的系统版本 (<em>iOS 14</em> )，那么生成的二进制包更小、使用时占用的内存更小 (<strong>smaller binaries</strong> and <strong>less memory usage</strong> )。这对 Objective-C 或 <em>Swift</em> 项目都是一个很好的建议。当 <em>Xcode</em> 知道它不需要支持旧的系统版本时，它通常可以生成优化地更好的代码或数据。</p><h3 id="mismatched-deployment-targets">Mismatched deployment targets</h3><p>假设我们有两个项目：</p><ol><li>一个是把 <em>minimum deployment target</em> 指定为 <em>iOS 14</em> 的 Framework ，Xcode 在构建它时，会使用 <em>relative method lists</em> ；<li>另一个是把 <em>minimum deployment target</em> 指定为 <em>iOS 13</em> 的 App ，Xcode 在构建它时，会使用旧格式的 <em>method lists</em> 。</ol><p>如果我们把上述 Framework 集成到上述 APP 中，在 iOS 13 系统上运行此 App 会出现问题。由于旧的系统版本没有处理 <em>relative method lists</em> 的机制，所以会读取两个<strong>32位</strong>的指针、当成一个<strong>64位</strong>指针使用。</p><p>这意味着两个独立的指针被合并成了一个值无效的指针，使用时肯定会导致 <em>crash</em> 。</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-relative-method-list-error.jpg" alt="runtime-relative-method-list-error.jpg" class="normal" width="600" /></p><h3 id="使用-runtime-apis-1">使用 Runtime APIs</h3><p>同样地，不要直接使用 Runtime 的私有类型，否则在新系统上这些私有类型的 layout 变化后，会导致 <em>crash</em> 。应该使用 Runtime 提供的公共 API 。</p><ul><li><code class="language-plaintext highlighter-rouge">method_getName</code><li><code class="language-plaintext highlighter-rouge">method_getTypeEncoding</code><li><code class="language-plaintext highlighter-rouge">method_getImplementation</code><li>…</ul><h2 id="3-arm64-架构上-tagged-pointer-格式的变化">3. ARM64 架构上 Tagged Pointer 格式的变化</h2><p>下文关于 <em>tagged pointer</em> 的介绍用到了几个术语，这里先做个解释：</p><ul><li><strong>tag bit</strong> : 共 <strong>1 bit</strong>，是 <em>tagged pointer</em> 的标志位；<li><strong>tag number</strong> : 共 <strong>3 bit</strong>，代表 <em>tagged pointer</em> 的类型；<li><strong>extended tag</strong> : 共 <strong>8 bit</strong>，代表 <em>tagged pointer</em> 的拓展类型，当 <em>tag number</em> 为 <em>7(0b111)</em> 时，就会使用 <em>extended tag</em> ；<li><strong>payload</strong> : <em>tagged pointer</em> 实际存储的内容。<ul><li>如果不使用 <em>extended tag</em>，<em>payload</em> 为 <strong>60 bit</strong>；<li>如果要使用 <em>extended tag</em>，<em>payload</em> 为 <strong>52 bit</strong>。</ul></ul><h3 id="普通的对象指针">普通的对象指针</h3><p>我们先看看普通的<em>对象指针 (object pointer)</em> 的结构。</p><p>普通的<em>对象指针</em>通常用很大的<em>十六进制 (hexadecimal)</em> 数字表示。下面我们把它分解成<em>二进制(binary)</em> 表示：</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-normal-object-pointer.jpg" alt="runtime-normal-object-pointer.jpg" /></p><p>在实际的<em>对象指针</em>中，只有中间的 bit 被使用了。</p><ul><li><em>低 3 位</em>的值总是 0 ，因为<strong>内存需要对齐：对象的地址值必须是指针大小的整数倍</strong>。 (<em>objects must always be located at an address that’s a multiple of the pointer size.</em> )<li><em>高 16 位</em>的值总是 0 ，因为需要的地址空间有限，实际上我们没有一直算到 <strong>2^64</strong> 。</ul><p>可以看出，普通的<em>对象指针</em>的<em>低 3 位</em>和<em>高 16 位</em>一直是 0 。</p><h3 id="intel">Intel</h3><p>在<strong>64位</strong> <em>Intel</em> 平台的 <em>Mac</em> 上，如果把<em>最低位 (bottom bit)</em> 设置为 1 ，就代表这个指针不是普通的<em>对象指针</em>，而是 <em>tagged pointer</em> ：</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-tagged-pointer-on-intel-1.jpg" alt="runtime-tagged-pointer-on-intel-1.jpg" /></p><p>在上图的示例中，我们创建了一个值为 42 的 <em>NSNumber</em> 。42 对应的二进制数是 101010 ，这个二进制数被放入了 <em>tagged pointer</em> 的第 5 至 10 位。</p><p>只要我们（指 Runtime 的开发者）教 <code class="language-plaintext highlighter-rouge">NSNumber</code> 如何读取这些<em>位</em>，并教 Runtime 正确处理 <em>tagged pointer</em> ，系统的其余部分就可以把这些东西当作<em>对象指针</em>，永远不知道其中的区别。</p><p>这节省了为较小的数值分配对象的开销，性能肯定会更好。</p><h4 id="混淆-tagged-pointer-的值">混淆 tagged pointer 的值</h4><p>我们获取到的 <em>tagged pointer</em> 的值是做了混淆的。Runtime 使用<em>进程启动时</em>创建的<em>随机值</em>与 <em>tagged pointer</em> 的值做了结合。这是一种安全措施，使 <em>tagged pointer</em> 难以被伪造。</p><p>所以，如果开发者尝试去读取内存中 <em>tagged pointer</em> 的值，获取到的将是被混淆的值。</p><h4 id="tag-number-和-payload">tag number 和 payload</h4><p>接下来的 3 <em>bit</em> 是 <em>tag number</em> ，代表 <em>tagged pointer</em> 的<em>类型</em>。比如 <em>3(0b011)</em> 代表 <code class="language-plaintext highlighter-rouge">NSNumber</code> ，<em>6(0b110)</em> 代表 <code class="language-plaintext highlighter-rouge">NSDate</code> 。</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-tagged-pointer-on-intel-2.jpg" alt="runtime-tagged-pointer-on-intel-2.jpg" /></p><p>因为 <em>tag number</em> 有 3 <em>bit</em> ，说明可以表示 8 种类型(0-7)。</p><p>剩下的 <em>bits</em> 是 <em>payload</em> ，用来存储值。对于 <em>tagged</em> <code class="language-plaintext highlighter-rouge">NSNumber</code> 来说， <em>payload</em> 存储的就是实际的数值。</p><h4 id="extended-tag">extended tag</h4><p><em>tag number</em> 等于 <em>7(0b111)</em> 是一个特殊的 case ，它代表要使用 <em>extended tag</em> 。</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-tagged-pointer-on-intel-3.jpg" alt="runtime-tagged-pointer-on-intel-3.jpg" /></p><p><em>extended tag</em> 使用接下来的 8 <em>bit</em> 来编码类型，以更小的 <em>payload</em> 为代价、来容纳 256 种新的 <em>tag</em> 类型。比如 <em>tagged</em> <code class="language-plaintext highlighter-rouge">UIColor</code>、<em>tagged</em> <code class="language-plaintext highlighter-rouge">NSIndexSet</code>。</p><h4 id="swift-中的-tagged-pointer">Swift 中的 tagged pointer</h4><p>只有 <em>Apple Runtime</em> 的开发人员才能添加 <em>tagged pointer</em> 类型。</p><p>但是在 Swift 开发中，可以创建自己的 <em>tagged pointer</em> 类型。比如，<em>Swift Runtime</em> 将<em>枚举标识符 (enum discriminator)</em> 存储在<em>关联值 (associated value) payload</em> 的<em>空余位 (spare bits)</em> 中。</p><p>更重要的是，<em>Swift</em> 对<em>值类型</em>的使用实际上降低了 <em>tagged pointer</em> 的重要性，because values no longer need to be exactly pointer sized（???）。</p><p>例如，一个 <em>Swift</em> <code class="language-plaintext highlighter-rouge">UUID</code> 类型可以是两个单词并且<em>内联 (inline)</em> 保存，而不是分配一个单独的对象，因为它不适合放在指针中（???）。</p><h3 id="arm64">ARM64</h3><h4 id="ios-13-中-tagged-pointer-的格式">iOS 13 中 tagged pointer 的格式</h4><p>和 <em>Intel</em> 平台不同的是，在 <em>ARM64</em> 平台上使用<em>最高位 (top bit)</em> 来标识 <em>tagged pointer</em> 。接下来的 <em>3 bits</em> 用于标识 tagged pointer 的类型，payload 使用剩下的 <em>bits</em> ：</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-tagged-pointer-on-arm64-overview.jpg" alt="runtime-tagged-pointer-on-arm64-overview.jpg" /></p><p>为什么在 <em>ARM</em> 平台上用 <em>top bit</em> 代表 <em>tagged pointer</em> 呢？</p><p>实际上这是为 <code class="language-plaintext highlighter-rouge">objc_msgSend</code> 做的一个小优化。</p><p>我们希望 <code class="language-plaintext highlighter-rouge">objc_msgSend</code> 中最常见的使用方式尽可能快，而最常见的使用方式是一个普通的对象指针调用 <code class="language-plaintext highlighter-rouge">objc_msgSend</code> 。</p><p>把 <em>top bit</em> 设置为 1 ，就能在一个判断中得知这个指针是 <em>tagged pointer</em> 或 <code class="language-plaintext highlighter-rouge">nil</code> ，这简化了普通对象指针调用 <code class="language-plaintext highlighter-rouge">objc_msgSend</code> 的流程，不用分别去判断 <em>tagged pointer</em> 和 <code class="language-plaintext highlighter-rouge">nil</code>：</p><div lang="c" class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">ptrValue</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// is tagged or nil</span>
</pre></table></code></div></div><p>说明：</p><ul><li><code class="language-plaintext highlighter-rouge">nil</code> 对应的指针值是 <code class="language-plaintext highlighter-rouge">0x0</code> ；<li>由于<em>最高位 (top bit)</em> 是<em>符号位</em>，当最高位是 1 是，指针值是一个负数。</ul><p>所有当指针值小于或等于 0 时，代表指针为 <em>tagged pointer</em> 或 <code class="language-plaintext highlighter-rouge">nil</code> 。</p><p>和 <em>Intel</em> <em>平台类似，ARM</em> 上的 <em>tag number</em> <em>7(0b111)</em> 代表要把接下来的 <em>8 bit</em> 用做 <em>extended tag</em> 。剩下的 <em>bits</em> 给 <em>payload</em> 使用：</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-tagged-pointer-on-arm64-old.jpg" alt="runtime-tagged-pointer-on-arm64-old.jpg" /></p><h4 id="ios-14-中-tagged-pointer-格式的变化">iOS 14 中 tagged pointer 格式的变化</h4><p>在 <em>iOS 14</em> 中，<em>tagged pointer</em> 的<em>标志位 (tag bit )</em>还是在<em>最高位</em>，因为这个对 <code class="language-plaintext highlighter-rouge">objc_msgSend</code> 的优化仍然很有用。</p><p>但是 <em>tag number</em> 挪到了<em>低 3 位 (bottom three bits)</em> ， <em>extended tag</em>（如果用到了）紧随 <em>tag bit</em> 后面。</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-tagged-pointer-on-arm64-new-1.jpg" alt="runtime-tagged-pointer-on-arm64-new-1.jpg" /></p><p>为什么要这样改呢？</p><p>我们再来看看 <em>tagged pointer</em> 和普通的<em>对象指针</em>的差异。</p><ul><li>我们现有的工具，比如动态链接器，由于一个名为 <strong>Top Byte Ignore(TBI)</strong><sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> 的 <em>ARM</em> 特性，会忽略指针的<em>高 8 位</em>。所有，我们可以把 <em>extended tag</em> 放在 <em>Top Byte Ignore</em> 位中，用于标识更多的 <em>tagged pointer</em> 类型。<li>对于一个<strong>对齐的</strong>普通对象指针，它的<em>低 3 位</em>总是 0 。将 <em>tagged pointer</em> 的 <em>tag number</em> 挪到<em>低 3 位</em>后 ，<em>低 3 位</em>的值为 <em>7(0b111)</em> 时，代表要使用 <em>extended tag</em> 。</ul><p>现在，<em>tagged pointer</em> 和普通的<em>对象指针</em>格式一致了，这意味着我们可以添加一个 <em>extended tag pointer</em> 类型，代表 payload 中存储的是一个指针类型的值。</p><p>因此，<strong>我们可以在 tagged pointer 的 payload 中存储一个普通的指针值了</strong>。</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-tagged-pointer-on-arm64-new-2.jpg" alt="runtime-tagged-pointer-on-arm64-new-2.jpg" /></p><p>这为什么很有用呢？</p><blockquote><p>Well, it opens up the ability for a tagged pointer to refer to constant data in your binary such as strings or other data structures that would otherwise have to occupy dirty memory.</p></blockquote><p>“它使 <em>tagged pointer</em> 能够<em>引用</em>二进制包中的<em>常量数据</em>，如字符串或其他数据结构，否则这些数据结构将不得不占用 <em>dirty memory</em> 。”</p><h3 id="使用-apis">使用 APIs</h3><p>不要在代码中依赖 Runtime 的内部细节。我们看一个案例：</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/runtime-tagged-pointer-on-arm64-error.jpg" alt="runtime-tagged-pointer-on-arm64-error.jpg" /></p><p>在上图的示例中，将指针值执行位操作、右移 60 ，如果结果为 <em>0xa(0b1010)</em> ，说明这个指针是存有 <code class="language-plaintext highlighter-rouge">NSString</code> 的 <em>tagged pointer</em> 。</p><p>在 <em>iOS 13</em> 上，这种写法确实没问题。右移后得到的 1010 这个值分为两部分：</p><ul><li>1 是指针的最高位，代表这个指针是 <em>tagged pointer</em><li>010 是 <em>tag number</em> ，代表这个指针是 <em>tagged</em> <code class="language-plaintext highlighter-rouge">NSString</code></ul><p>但在 <em>iOS 14</em> 上，由于 <em>tag number</em> 被移到了<em>低 3 位</em>，所以上面代码中的判断在新系统上不再准确。</p><p>应该使用 <code class="language-plaintext highlighter-rouge">isKindOfClass</code> 这种公开的 API 来判断指针类型，而不要依赖 Runtime 中的内部细节。</p><p>最后，演讲人又说了两段话来解释为什么不要在代码中依赖 Runtime 的内部细节，值得引起（喜欢在生产环境中使用系统私有 API 的）开发者们的注意：</p><blockquote><p>We don’t want to hide anything and we definitely don’t want to break anybody’s apps.</p></blockquote><p>“我们不想隐藏任何东西，也绝对不想破坏任何人的 APP 。”</p><blockquote><p>When these details aren’t exposed, it’s just because we need to maintain the flexibility to make changes like this, and your apps will keep working just fine, as long as they don’t rely on these internal details.</p></blockquote><p>“这些细节没有被公开，只是因为我们需要保持灵活性来做出类似上文中的优化。只要你的 APP 不依赖于这些内部细节，它们将继续正常工作。”</p><h2 id="小结">小结</h2><p>以 <em>PPT</em> 里的总结来结尾吧：</p><p><img data-proofer-ignore data-src="/images/WWDC/2020/10163-OC-Runtime-Changes/wrap-up.jpg" alt="wrap-up.jpg" class="normal" width="500" /></p><h3 id="相关资料">相关资料</h3><ul><li>笔者整理的 <em>WWDC</em> 资料库，含讲稿（字幕）：<a href="https://github.com/Bob-Playground/WWDC-Stuff">https://github.com/Bob-Playground/WWDC-Stuff</a></ul><h2 id="reference">Reference</h2><div class="footnotes" role="doc-endnotes"><ol><li id="fn:1" role="doc-endnote"><p><strong>Top Byte Ignore(TBI)</strong> : 是 <em>ARMv8</em> 引入的一个特性，它通过忽略虚拟地址 (<em>virtual address</em> )的<em>高 8 位</em>来提供内存标记工具。这允许软件使用一个<strong>64位</strong>指针的<em>高 8 位</em>作为标签。参考：<a href="https://en.wikichip.org/wiki/arm/tbi">https://en.wikichip.org/wiki/arm/tbi</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p></ol></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE/'>攻城狮</a>, <a href='/categories/wwdc/'>WWDC</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/wwdc-2020/" class="post-tag no-text-decoration" >WWDC 2020</a> <a href="/tags/ios/" class="post-tag no-text-decoration" >iOS</a> <a href="/tags/objective-c-runtime/" class="post-tag no-text-decoration" >Objective-C Runtime</a> <a href="/tags/class-rw-ext-t/" class="post-tag no-text-decoration" >class_rw_ext_t</a> <a href="/tags/reletive-method-list/" class="post-tag no-text-decoration" >Reletive Method List</a> <a href="/tags/tagged-pointer/" class="post-tag no-text-decoration" >Tagged Pointer</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> <span class="text-muted small">-- Missing configuration options! --</span></div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <i class="fa-fw fas fa-link small" onclick="copyLink('', '')" data-toggle="tooltip" data-placement="top" title=""> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/App-Startup-Time-dyld/">【WWDC17】优化 APP 启动（dyld 2 -> dyld 3）</a><li><a href="/posts/forceFullDesktopBar/">在 macOS 的 Mission Control 中展示完整的桌面预览</a><li><a href="/posts/Optimizing-App-Startup-Time/">[WIP]【WWDC16】优化 App 启动（基于 dyld 2）</a><li><a href="/posts/Objective-C-Runtime-Changes-in-iOS-14/">【iOS 14】Objective-C Runtime 的优化</a><li><a href="/posts/Optimizing-App-Launch/">【WWDC19】优化 APP 启动（基于 dyld 3）</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ios/">iOS</a> <a class="post-tag" href="/tags/app-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/">APP 启动优化</a> <a class="post-tag" href="/tags/app-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">APP 性能优化</a> <a class="post-tag" href="/tags/objective-c-runtime/">Objective-C Runtime</a> <a class="post-tag" href="/tags/proxy/">Proxy</a> <a class="post-tag" href="/tags/shadowsocks/">Shadowsocks</a> <a class="post-tag" href="/tags/%E5%85%B3%E4%BA%8E%E5%86%99%E5%8D%9A%E5%AE%A2/">关于写博客</a> <a class="post-tag" href="/tags/app-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/">App 启动优化</a> <a class="post-tag" href="/tags/app-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">App 性能优化</a> <a class="post-tag" href="/tags/class-rw-ext-t/">class_rw_ext_t</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/the-difference-between-selector-method-message-in-ObjC/"><div class="card-body"> <span class="timeago small" >Apr 4, 2017<i class="unloaded">2017-04-04T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>ObjC 中 selector, method, message 的区别</h3><div class="text-muted small"><p> 有点晚了, 先占个坑待填. selector, 方法名 method, selector 及 method 的实现. message, selector 及 所需的参数. #import "InteractiveSectionController.h" #import "InteractiveCell.h" @implementation InteractiveSectionCon...</p></div></div></a></div><div class="card"> <a href="/posts/LLDB-beyond-po/"><div class="card-body"> <span class="timeago small" >Mar 2<i class="unloaded">2021-03-02T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>po、p、v 命令；LLDB 的自定义 Data Formatter；在 LLDB 中使用 Python 脚本</h3><div class="text-muted small"><p> 目录 前言 LLDB 常用命令 po、p、v LLDB 常用命令一：po po 的常见用法 po 是 expression 命令的 alias 创建自定义的 alias po 的原理 LLDB 常用命令二：p ...</p></div></div></a></div><div class="card"> <a href="/posts/Optimizing-App-Launch/"><div class="card-body"> <span class="timeago small" >Jun 6<i class="unloaded">2021-06-06T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>【WWDC19】优化 APP 启动（基于 dyld 3）</h3><div class="text-muted small"><p> 目录 前言 1. 什么是启动 暖场小故事 为什么启动很重要 1. 第一印象 2. 可以反映整体的代码质量 3. 性能 启动的类型 1. 冷启动 2. 热启动 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/LLDB-beyond-po/" class="btn btn-outline-primary" prompt="previous"><p>po、p、v 命令；LLDB 的自定义 Data Formatter；在 LLDB 中使用 Python 脚本</p></a> <a href="/posts/Optimizing-App-Launch/" class="btn btn-outline-primary" prompt="next"><p>【WWDC19】优化 APP 启动（基于 dyld 3）</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://github.com/Huang-Libo">Huang Libo</a>. <span class="text-muted">-- Missing configuration options! --</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/ios/">iOS</a> <a class="post-tag" href="/tags/app-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/">APP 启动优化</a> <a class="post-tag" href="/tags/app-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">APP 性能优化</a> <a class="post-tag" href="/tags/objective-c-runtime/">Objective C Runtime</a> <a class="post-tag" href="/tags/proxy/">Proxy</a> <a class="post-tag" href="/tags/shadowsocks/">Shadowsocks</a> <a class="post-tag" href="/tags/%E5%85%B3%E4%BA%8E%E5%86%99%E5%8D%9A%E5%AE%A2/">关于写博客</a> <a class="post-tag" href="/tags/app-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/">App 启动优化</a> <a class="post-tag" href="/tags/app-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">App 性能优化</a> <a class="post-tag" href="/tags/class-rw-ext-t/">class_rw_ext_t</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://Huang-Libo.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
