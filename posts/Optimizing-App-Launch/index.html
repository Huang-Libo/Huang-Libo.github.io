<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="layout-lang" content="zh-CN"><meta name="day-prompt" content="d ago"><meta name="hour-prompt" content="hr ago"><meta name="minute-prompt" content="min ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="【WWDC19】优化 APP 启动（基于 dyld 3）" /><meta name="author" content="BOB" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="目录" /><meta property="og:description" content="目录" /><link rel="canonical" href="https://huang-libo.github.io/posts/Optimizing-App-Launch/" /><meta property="og:url" content="https://huang-libo.github.io/posts/Optimizing-App-Launch/" /><meta property="og:site_name" content="BOB’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-06-06T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="【WWDC19】优化 APP 启动（基于 dyld 3）" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@BOB" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"BOB"},"description":"目录","url":"https://huang-libo.github.io/posts/Optimizing-App-Launch/","@type":"BlogPosting","headline":"【WWDC19】优化 APP 启动（基于 dyld 3）","dateModified":"2021-07-30T14:07:58+08:00","datePublished":"2021-06-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://huang-libo.github.io/posts/Optimizing-App-Launch/"},"@context":"https://schema.org"}</script><title>【WWDC19】优化 APP 启动（基于 dyld 3） | BOB's blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="BOB's blog"><meta name="application-name" content="BOB's blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang=""><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/favicon.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">BOB's blog</a></div><div class="site-subtitle font-italic">Just for Fun!</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/Huang-Libo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['LiboHwang+IM','gmail.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-5" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>【WWDC19】优化 APP 启动（基于 dyld 3）</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>【WWDC19】优化 APP 启动（基于 dyld 3）</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Huang Libo </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Jun 6, 2021, 12:00 AM +0800" >Jun 6<i class="unloaded">2021-06-06T00:00:00+08:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Fri, Jul 30, 2021, 2:07 PM +0800" >Jul 30<i class="unloaded">2021-07-30T14:07:58+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5024 words">27 minread</span></div></div><div class="post-content"><p><h2>目录</h2></p><ul><li><a href="#前言">前言</a><li><a href="#1-什么是启动">1. 什么是启动</a><ul><li><a href="#暖场小故事">暖场小故事</a><li><a href="#为什么启动很重要">为什么启动很重要</a><ul><li><a href="#1-第一印象">1. 第一印象</a><li><a href="#2-可以反映整体的代码质量">2. 可以反映整体的代码质量</a><li><a href="#3-性能">3. 性能</a></ul><li><a href="#启动的类型">启动的类型</a><ul><li><a href="#1-冷启动">1. 冷启动</a><li><a href="#2-热启动">2. 热启动</a><li><a href="#3-resume">3. Resume</a></ul><li><a href="#不同启动类型的对比">不同启动类型的对比</a><li><a href="#启动的目标耗时400毫秒">启动的目标耗时：400毫秒</a><li><a href="#案例maps-app-的启动">案例：Maps APP 的启动</a><li><a href="#启动的-6-个阶段">启动的 6 个阶段</a><ul><li><a href="#1-system-interface">1. System Interface</a><ul><li><a href="#11-dyld">1.1 dyld</a><li><a href="#12-libsysteminit">1.2 libSystemInit</a></ul><li><a href="#2-static-runtime-initialization">2. Static Runtime Initialization</a><li><a href="#3-uikit-initialization">3. UIKit Initialization</a><li><a href="#4-application-initialization">4. Application Initialization</a><ul><li><a href="#app-lifecycle-callbacks">APP lifecycle callbacks</a><li><a href="#ui-lifecycle-callbacks">UI lifecycle callbacks</a></ul><li><a href="#5-first-frame-render">5. First Frame Render</a><li><a href="#6-extended-phase">6. Extended Phase</a></ul><li><a href="#系统侧的优化">系统侧的优化</a></ul><li><a href="#2-正确地测量启动">2. 正确地测量启动</a><ul><li><a href="#控制变量">控制变量</a><li><a href="#测量前的准备工作">测量前的准备工作</a><ul><li><a href="#1-重启设备">1. 重启设备</a><li><a href="#2-消除网络影响">2. 消除网络影响</a><li><a href="#3-消除-icloud-的影响">3. 消除 iCloud 的影响</a><li><a href="#4-使用-release-build">4. 使用 release build</a><li><a href="#5-测量热启动">5. 测量热启动</a><li><a href="#6-准备多份-mock-数据">6. 准备多份 mock 数据</a></ul><li><a href="#选择测量的机器">选择测量的机器</a><li><a href="#优化启动的步骤">优化启动的步骤</a><ul><li><a href="#1-minimize--减少与启动无关的任务">1. Minimize : 减少与启动无关的任务</a><li><a href="#2-prioritize--确定任务的优先顺序">2. Prioritize : 确定任务的优先顺序</a><li><a href="#3-optimize--优化现有的任务">3. Optimize : 优化现有的任务</a></ul></ul><li><a href="#3-demo测量启动的工具">3. Demo：测量启动的工具</a><ul><li><a href="#使用-instrument---app-launch-template">使用 Instrument - App Launch Template</a><ul><li><a href="#app-生命周期app-life-cycle">APP 生命周期（APP life cycle）</a><li><a href="#线程状态thread-state">线程状态（Thread State）</a><li><a href="#查看启动阶段的详情">查看启动阶段的详情</a><li><a href="#cpu-clock--wall-clock">CPU clock &amp; Wall clock</a><li><a href="#线程的优先级">线程的优先级</a><li><a href="#线程优先级反转的问题">线程优先级反转的问题</a><li><a href="#代码分析">代码分析</a></ul><li><a href="#使用-xctest-测量启动">使用 XCTest 测量启动</a><li><a href="#长期追踪启动数据">长期追踪启动数据</a><ul><li><a href="#1-使用-xcode-organizer-收集启动数据">1. 使用 Xcode Organizer 收集启动数据</a><li><a href="#2-使用-metrickit-收集更详细的统计数据">2. 使用 MetricKit 收集更详细的统计数据</a></ul></ul><li><a href="#总结">总结</a><li><a href="#相关文章">相关文章</a></ul><h2 id="前言">前言</h2><p><a href="https://developer.apple.com/videos/play/wwdc2019/423/">WWDC 2019 / 423 - Optimizing App Launch</a> 介绍了 <em>APP</em> 启动的流程，以及测量和优化启动的方法，演讲者来自 <em>Performance Team</em> 。内容包含：</p><ul><li>什么是启动、启动的类型、启动的阶段；<li>如何正确地测量启动、测量时需要排除的干扰因素，以及要关注老设备的性能表现；<li>使用 <em>Instruments</em> 剖析启动的过程，使用 <em>XCTest</em> 做自动化的启动统计；<li>使用 <em>MetricKit</em> 和 <em>Xcode Organizer</em> 长期追踪启动数据。</ul><p>相关资源：笔者整理过的<a href="https://github.com/Bob-Playground/WWDC-Stuff/blob/master/2019/423-Optimizing-App-Launch/Optimizing-App-Launch-Edited.md">讲稿（视频的字幕）</a>。</p><h2 id="1-什么是启动">1. 什么是启动</h2><h3 id="暖场小故事">暖场小故事</h3><p>“全球的 <em>iOS</em> 设备<em>每天</em>要启动各种 <em>APP</em> 数十亿次。”</p><p>如果每次启动能节省一毫秒，那么能节省 162 天（即所有 <em>iOS</em> 设备在一天内启动 <em>APP</em> 可节省的总时间），这是将🚀发射到火星所需要的时间。</p><p>他们计算的方式应该是这样的：</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>14*1,000,000,000/1000/60/60/24 ≈ 162天
</pre></table></code></div></div><p>这个小故事和“全国每个人给我一块钱我就有 13 亿块钱了”有异曲同工之妙，哈哈。</p><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-162-days-to-mars.jpg" alt="APP-launch-162-days-to-mars" /> <em>把🚀送上火星需要162天</em></p><h3 id="为什么启动很重要">为什么启动很重要</h3><blockquote><p>App launch is a user experience interruption.</p></blockquote><p>“<em>APP</em> 启动是用户体验的中断。”</p><h4 id="1-第一印象">1. 第一印象</h4><p>启动是用户对 <em>APP</em> 的第一印象，因此，它应该是令人愉悦的。</p><p>另外，开发者倾向于关注更新的设备，但我们得保障使用旧机型的用户也有比较好的 <em>APP</em> 使用体验。</p><h4 id="2-可以反映整体的代码质量">2. 可以反映整体的代码质量</h4><p>启动通常包含了大量的代码，包括 <em>primer coating</em>（？？）、<em>initialization</em>、<em>view creation</em> 等。</p><p>因此，如果启动的体验不好，就暗示着代码中其他模块的使用体验可能也不好。</p><h4 id="3-性能">3. 性能</h4><p>对于手机来说，启动是一个非常紧张的时刻。它包含了大量的 <em>CPU</em> 和<em>内存</em>的工作。</p><p>因此，开发者应该尝试减少这部分的工作，因为它会影响<em>系统的性能</em>和<em>电池的消耗量</em>。</p><h3 id="启动的类型">启动的类型</h3><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-type-1.jpg" alt="APP-launch-type-1" /></p><h4 id="1-冷启动">1. 冷启动</h4><p>冷启动（<em>cold launch</em>）发生在重启后（或者 <em>APP</em> 很长时间没有被启动过）。</p><p>在这种情况下，如果要启动一个 <em>APP</em> ，需要：</p><ul><li>将它从<em>磁盘</em>加载到<em>内存</em>；<li>启动支撑 <em>APP</em> 运行的系统侧服务（<em>system-side services</em>）；<li>创建 <em>APP</em> 的进程。</ul><h4 id="2-热启动">2. 热启动</h4><p>如果 <em>APP</em> 最近启动过，下次启动将会是热启动（<em>warm launch</em>）。</p><p><strong>热启动也需要创建进程</strong>，但此时 <em>APP</em> 的一部分已经在<em>内存</em>中，一些系统侧的服务也已经启动了。</p><p>因此，热启动要比冷启动要快一些。</p><h4 id="3-resume">3. Resume</h4><p>如果 <em>APP</em> 的进程还存在，当用户从 <em>Home screen</em> 或者 <em>APP switcher</em> 重新进入 <em>APP</em> 时，就是 <em>resume</em>。</p><p><em>resume</em> <strong>不算启动</strong>（<em>isn’t quite a launch</em>），APP 在之前已经完成了启动。所以 <em>resume</em> 的速度很快。</p><p>因此要注意：在做启动测量时，不要把启动和 <em>resume</em> 混淆了。</p><h3 id="不同启动类型的对比">不同启动类型的对比</h3><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-type-2.jpg" alt="APP-launch-type-2" /></p><p>简单翻译一下：</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">冷启动<th style="text-align: center">热启动<th style="text-align: center">Resume<tbody><tr><td style="text-align: center">重启后<td style="text-align: center">最近被终止<td style="text-align: center">APP 被挂起<tr><td style="text-align: center">APP 不在内存中<td style="text-align: center">APP 部分在内存中<td style="text-align: center">APP 全部在内存中<tr><td style="text-align: center">进程不存在<td style="text-align: center">进程不存在<td style="text-align: center">进程存在</table></div><h3 id="启动的目标耗时400毫秒">启动的目标耗时：400毫秒</h3><p>在 <strong>400 毫秒</strong>内展示第一帧。</p><p>也就是说，在启动动画（<em>launch animation</em>）完成前，就应该完成 <em>UI</em> 的展示；当启动动画结束后，<em>APP</em> 就应该是可交互的（<em>interactive</em>）、可响应的（<em>responsive</em>）。</p><h3 id="案例maps-app-的启动">案例：Maps APP 的启动</h3><p>用户点击了 <em>Maps</em> 的图标，系统开始执行启动：</p><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-phases-Maps-1.jpg" alt="APP-launch-phases-Maps-1" class="normal" width="600" /></p><p>前 <strong>100 毫秒</strong>（紫色部分），<em>iOS</em> 系统会做初始化 <em>APP</em> 所需的系统侧工作：</p><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-phases-Maps-2.jpg" alt="APP-launch-phases-Maps-2" class="normal" width="600" /></p><p>这给了开发者大约 <strong>300 毫秒</strong>（绿色部分）的时间去创建视图、加载内容、生成 <em>APP</em> 的第一帧，也就是说，在 <strong>400 毫秒</strong>内完成启动并展示第一帧。</p><p>第一帧不需要是全部完成的状态，可以为异步加载的数据展示 <em>placeholder</em> ，但 <em>APP</em> 此时应该是可响应、可交互的。这个阶段完成后，用户可以搜索和查看自己的收藏，等等：</p><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-phases-Maps-3.jpg" alt="APP-launch-phases-Maps-3" class="normal" width="600" /></p><p>在接下来的几百毫秒里，当异步数据加载完成后，显示最终的页面：</p><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-phases-Maps-4.jpg" alt="APP-launch-phases-Maps-4" class="normal" width="600" /></p><h3 id="启动的-6-个阶段">启动的 6 个阶段</h3><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-phases-overall.jpg" alt="APP-launch-phases-overall" /></p><h4 id="1-system-interface">1. System Interface</h4><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-phases-1.jpg" alt="APP-launch-phases-1" /></p><h5 id="11-dyld">1.1 dyld</h5><p><em>System Interface</em> 的前半部分是 <strong>dyld（the dynamic linker）</strong>阶段，它的作用是加载 <em>shared libraries</em> 和 <em>frameworks</em> 。</p><p>查看 <code class="language-plaintext highlighter-rouge">dyld</code> 的文档：</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>man dyld
</pre></table></code></div></div><p>输出：</p><p><img data-proofer-ignore data-src="/images/WWDC/Common/man-dyld.jpg" alt="man-dyld.jpg" /></p><p>在 <em>WWDC17</em>，<em>Apple</em> 推出了 <em>dyld 3</em>，为系统添加了令人兴奋的优化。</p><ul><li>2017 年，<em>iOS 11</em> 的系统自带 APP 开始使用 <em>dyld 3</em> ，第三方 APP 还是使用 <em>dyld 2.x</em> 。<li>2019 年，<em>iOS 13</em> 的系统自动 APP 和第三方 APP 都使用 <em>dyld 3</em> 。</ul><p>在使用 <em>dyld 3</em> 后，系统会<em>缓存运行时依赖项 (caching runtime dependencies)</em> ，这给<em>热启动</em>带来显著的速度改进。</p><p>相关 <em>Session</em> ：</p><ul><li><a href="https://developer.apple.com/videos/play/wwdc2017/413/">WWDC17 / 413 - App Startup Time: Past, Present, and Future</a></ul><p>在 <em>dyld 3</em> 阶段的几个建议：</p><ul><li>✅ 避免链接未用到的 <em>frameworks</em> 。<li>✅ 避免在启动时加载动态库，比如 <code class="language-plaintext highlighter-rouge">dlopen</code> 和 <code class="language-plaintext highlighter-rouge">NSBundle load</code>。因为这样就失去了 <em>dyld 3 缓存运行时依赖项</em>带来的好处。<li>✅ （根据上一条）最后，这意味着要<em>硬链接 (Hard link)</em> 所有的依赖，它比以前更快。</ul><h5 id="12-libsysteminit">1.2 libSystemInit</h5><p><em>System Interface</em> 的后半部分是 <em>libSystemInit</em> 。在这个阶段，系统初始化 APP 内用到的<em>底层系统组件（low-level system components）</em>。</p><p>这主要是具有<em>固定时间开销</em>的系统端工作，<em>APP</em> 开发者不用太关心。</p><h4 id="2-static-runtime-initialization">2. Static Runtime Initialization</h4><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-phases-2.jpg" alt="APP-launch-phases-2" /></p><p>这是系统初始化 <em>APP</em> 的 <strong>Objective-C 和 Swift 的 Runtime</strong> 的时候。</p><p>一般而言，<em>APP</em> 在这个阶段不会做任何工作，除非 <em>APP</em> 中包含<em>静态初始化方法（static initializer method）</em> ，可能是 <em>APP</em> 代码中的，也可能是 <em>APP</em> 链接的 <em>framework</em> 中的。</p><p><strong>不建议使用静态初始化方法</strong>。</p><p>下面给两个建议：</p><ul><li>✅ <em>Framework</em> 的开发者应该考虑暴露初始化的 <em>API</em> ，避免使用静态初始化。<li>✅ 如果一定要使用静态初始化，考虑把 <code class="language-plaintext highlighter-rouge">+load</code> 方法中的代码移到 <code class="language-plaintext highlighter-rouge">+initialize</code> 方法中。因为 <code class="language-plaintext highlighter-rouge">+load</code> 方法在每次启动 APP 的时候就会调用，而 <code class="language-plaintext highlighter-rouge">+initialize</code> 方法会在第一次使用这个<em>类</em>的时候调用。</ul><h4 id="3-uikit-initialization">3. UIKit Initialization</h4><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-phases-3.jpg" alt="APP-launch-phases-3" /></p><p>这是系统初始化 <code class="language-plaintext highlighter-rouge">UIApplication</code> 和 <code class="language-plaintext highlighter-rouge">UIApplicationDelegate</code> 的阶段。</p><p>在大多数情况下，这是系统端的工作，设置<em>事件处理（event processing）</em>以及与系统集成。</p><p>但是如果开发者子类化了 <code class="language-plaintext highlighter-rouge">UIApplication</code> ，或者在 <code class="language-plaintext highlighter-rouge">UIApplicationDelegate</code> 的初始化方法中做了额外的工作，将会影响这阶段的耗时。</p><p>因此，如果做了上述定制化的事情，确保以下两点：</p><ul><li>✅ 减少 <code class="language-plaintext highlighter-rouge">UIApplication</code> 子类中的工作。<li>✅ 减少 <code class="language-plaintext highlighter-rouge">UIApplicationDelegate</code> 初始化方法中的工作。</ul><h4 id="4-application-initialization">4. Application Initialization</h4><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-phases-4.jpg" alt="APP-launch-phases-4" /></p><p><em>Application</em> 初始化阶段是开发者对启动时间影响最大的阶段。</p><h5 id="app-lifecycle-callbacks">APP lifecycle callbacks</h5><p>无论是否使用了 <code class="language-plaintext highlighter-rouge">UIScene</code> 相关的 <em>API</em> ，都会先调用 <code class="language-plaintext highlighter-rouge">UIApplicationDelegate</code> 的 <em>APP lifecycle callbacks</em> ：</p><div lang="objc" class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nl">application:willFinishLaunchingWithOptions:</span>
<span class="n">application</span><span class="o">:</span><span class="n">didFinishLaunchingWithOptions</span><span class="o">:</span>
</pre></table></code></div></div><h5 id="ui-lifecycle-callbacks">UI lifecycle callbacks</h5><ul><li>如果没有使用 <code class="language-plaintext highlighter-rouge">UIScene</code> ，当 <em>UI</em> 展示给用户的时候，再调用 <code class="language-plaintext highlighter-rouge">UIApplicationDelegate</code> 的 <em>UI lifecycle callbacks</em> ：</ul><div lang="objc" class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nl">applicationDidBecomeActive:</span>
</pre></table></code></div></div><ul><li>如果使用了 <em>iOS 13</em> 推出的 <code class="language-plaintext highlighter-rouge">UIScene</code> ，当 <em>UI</em> 展现给用户时，会为每个 <em>scene</em> 调用 <code class="language-plaintext highlighter-rouge">UISceneDelegate</code> 的 <em>UI lifecycle callbacks</em> ：</ul><div lang="objc" class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">scene:willConnectToSession:options:</span>
<span class="n">sceneWillEnterForeground</span><span class="o">:</span>
<span class="n">sceneDidBecomeActive</span><span class="o">:</span>
</pre></table></code></div></div><p><em>Application Initialization</em> 阶段的建议：</p><ul><li>✅ 推迟与 APP 启动无关的工作，或放在子线程执行<li>✅ 如果使用了 <code class="language-plaintext highlighter-rouge">UIScene</code> ，请在 scene 之间共享资源，避免做重复的工作。</ul><p><code class="language-plaintext highlighter-rouge">UIScene</code> 相关介绍请查看：</p><ul><li><a href="https://developer.apple.com/documentation/uikit/app_and_environment/managing_your_app_s_life_cycle?language=objc">Apple Article - Managing Your App’s Life Cycle</a><li><a href="https://developer.apple.com/videos/play/wwdc2019/212">WWDC 2019 / 212 - Introducing Multiple Windows on iPad</a></ul><h4 id="5-first-frame-render">5. First Frame Render</h4><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-phases-5.jpg" alt="APP-launch-phases-5" /></p><p>在这个阶段的任务是创建 view 、布局 view 、最后绘制 view 。</p><p>当系统拿到 view 的这些信息，就执行 <code class="language-plaintext highlighter-rouge">commit</code> 和 <code class="language-plaintext highlighter-rouge">render</code> ，完成第一帧的展示。</p><p>在这个阶段，会调用这些方法：</p><div lang="objc" class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">loadView</span>
<span class="n">viewDidLoad</span>
<span class="n">layoutSubviews</span>
</pre></table></code></div></div><p>建议有：</p><ul><li>✅ 减少 view 的层级、懒加载不需要在启动时展示的 view 。<li>✅ 优化 auto layout ，减少不必要的约束。</ul><p>相关 <em>Session</em> :</p><ul><li><a href="https://developer.apple.com/videos/play/wwdc2018/220/">WWDC 2018 / 220 - High Performance Auto Layout</a></ul><h4 id="6-extended-phase">6. Extended Phase</h4><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-phases-6.jpg" alt="APP-launch-phases-6" /></p><ul><li>App-specific period after first frame<li>Displays asynchronously loaded data<li>App should be interactive and responsive</ul><p>在这个阶段可异步加载数据，加载完成后，给用户展示最终的页面。但是，在进入这个阶段之前，APP 就应该是<em>可交互、可响应</em>的，不能因为数据的加载而阻断 UI 交互。</p><p>建议：</p><ul><li>✅ 使用 <code class="language-plaintext highlighter-rouge">os_signpost</code> 来测量这阶段的工作</ul><h3 id="系统侧的优化">系统侧的优化</h3><p><em>iOS 13</em> 做了一系列优化，其中一些优化可显著地加快启动速度，如：引入 dyld 3 、缓存 APP 的运行时依赖项、Auto Layout 的优化、Scheduler 的优化、Runtime 的优化，等等。</p><p>开发者只需要稍作调整，甚至都不需要做任何事情，启动就会变得更快。</p><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-System-Improvements.jpg" alt="APP-launch-System-Improvements" /></p><h2 id="2-正确地测量启动">2. 正确地测量启动</h2><h3 id="控制变量">控制变量</h3><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-measure-control-variables.png" alt="APP-launch-measure-control-variables" /> <em>测量时要控制变量</em></p><p>在任何时候，iOS 设备都处于各种不同的状态和条件下，这可能会给启动带来很大的变化。</p><p>所以，当我们分析和比较启动数据时，要控制变量、消除不可控因素，保障启动的<em>可预测性</em>和<em>一致性</em>。比如，消除<em>网络的干扰</em>和<em>后台进程的干扰</em>。</p><p>这听起来违反直觉，因为这样启动并不是常规的使用方式，但这是没关系的，在测量启动数据时，更重要的是取得一致的结果，以此来评估进展。</p><h3 id="测量前的准备工作">测量前的准备工作</h3><p>在测量前，需要设置干净和一致的环境，下面给出一些建议。</p><h4 id="1-重启设备">1. 重启设备</h4><p>重启设备将清除任何不必要的状态，然后让它在接下来的几分钟内稳定下来，以使系统的启动全部完成。</p><h4 id="2-消除网络影响">2. 消除网络影响</h4><p>每次网络请求获得的数据量大小可能差别很大，要消除这些变化带来的影响，可以使用飞行模式，或者使用 mock 数据。</p><h4 id="3-消除-icloud-的影响">3. 消除 iCloud 的影响</h4><p>使用同一个 iCloud 账号，并保持其数据内容不变，或者直接退出 iCloud 账号，以消除 iCloud 后台进程对测量的干扰。</p><h4 id="4-使用-release-build">4. 使用 release build</h4><p>使用 <em>release build</em> 可在测量过程中减少不必要的<em>调试代码</em>带来的开销，且可以获得编译时的优化。</p><h4 id="5-测量热启动">5. 测量热启动</h4><p>应该使用<em>热启动</em>进行测量，其测量结果是更加一致的（ <em>more consistent</em> ），因为 APP 的一部分可能已经在<em>内存</em>中，并且一些<em>系统端服务</em>可能已经在运行。</p><h4 id="6-准备多份-mock-数据">6. 准备多份 mock 数据</h4><p>开发者可能需要准备多份 mock 数据，来模拟<strong>不同数据规模</strong>对启动的影响。最好做到只加载显示第一帧所需的数据。</p><h3 id="选择测量的机器">选择测量的机器</h3><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-older-and-newer-devices.jpg" alt="APP-launch-older-and-newer-devices" class="normal" width="600" /></p><p>在选择要测量机器时，请确保包含<em>最老支持的系统版本中的最老的设备</em>。以保障所有的用户都能有较好的 APP 启动体验。</p><h3 id="优化启动的步骤">优化启动的步骤</h3><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-optimize-steps.jpg" alt="APP-launch-optimize-steps" /></p><h4 id="1-minimize--减少与启动无关的任务">1. Minimize : 减少与启动无关的任务</h4><ul><li>✅ 延迟执行与展示第一帧不相关的任务<li>✅ 避免阻塞主线程<li>✅ 降低内存的使用</ul><h4 id="2-prioritize--确定任务的优先顺序">2. Prioritize : 确定任务的优先顺序</h4><ul><li>✅ 为任务确定正确的 <em>QoS</em><li>✅ 利用 <em>scheduler</em> 为 APP 启动做的优化（ Utilize <em>scheduler</em> optimizations for app launch ）<li>✅ 使用正确的原语保持优先级（ Preserve the priority with the right primitives ）</ul><p>相关 <em>Session</em> :</p><ul><li><a href="https://developer.apple.com/videos/play/wwdc2017/706/">WWDC17 / 706 - Modernizing Grand Central Dispatch Usage</a></ul><h4 id="3-optimize--优化现有的任务">3. Optimize : 优化现有的任务</h4><ul><li>✅ 简化或限制当前任务<li>✅ 优化算法和数据结构<li>✅ 缓存资源和计算结果</ul><h2 id="3-demo测量启动的工具">3. Demo：测量启动的工具</h2><blockquote><p>演讲人用一个 Demo 项目演示了 <em>App Launch Template</em> 的使用方法，这里只做个要点记录，代码详情可去看原视频。</p></blockquote><p>在测量前，先执行 Profile ( <kbd>cmd</kbd> + <kbd>I</kbd> ) ，此时 Xcode 会以 <em>Release</em> 模式重新编译 APP ，编译和安装后，会自动打开 Instrument 。</p><h3 id="使用-instrument---app-launch-template">使用 Instrument - App Launch Template</h3><p>在 <em>Xcode 11</em> 中新增了 <em>App Launch Template</em> ，专门用于测量 APP 的启动：</p><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-instrument-1.jpg" alt="APP-launch-instrument-1" /></p><h4 id="app-生命周期app-life-cycle">APP 生命周期（APP life cycle）</h4><ul><li><strong>紫色部分</strong>发生在 <code class="language-plaintext highlighter-rouge">main</code> 方法调用前。<li><strong>绿色部分</strong>发生在 <code class="language-plaintext highlighter-rouge">main</code> 方法调用后的早期阶段，APP 在这个阶段完成启动并绘制第一帧。<li><strong>蓝色部分</strong>对应 <em>Extended phase</em> ，做一些异步的任务，拿到数据后再绘制最终的视图。</ul><h4 id="线程状态thread-state">线程状态（Thread State）</h4><ul><li><strong>灰色</strong>表示线程<strong>被阻塞了（Blocked）</strong>，意味着线程没有做任何工作。<li><strong>红色</strong>表示线程是<strong>可运行的（Runnable）</strong>，意味着有工作计划要完成，但缺乏CPU资源。<li><strong>橙色</strong>表示线程<strong>被抢占了（Preempted）</strong>，也就是说它正在做某项工作，但是被其他具有更高优先级的竞争性任务打断了。<li><strong>蓝色</strong>表示线程<strong>正在运行（Running）</strong>，也就是说它正在使用 CPU 执行任务。</ul><h4 id="查看启动阶段的详情">查看启动阶段的详情</h4><p><strong>三击</strong>一个启动阶段，可以突出显示该阶段并获得详细信息：</p><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-instrument-2.jpg" alt="APP-launch-instrument-2" /></p><ul><li>在左边，可以看到这段时间内所有任务的详细<em>堆栈</em>跟踪。<li>在右边，可以看到一个聚合的<em>堆栈</em>跟踪，它列出了按 CPU 样本大小的数量排序的所有<em>符号</em>（ all of the symbols ordered by the number of CPU sample size ）。</ul><h4 id="cpu-clock--wall-clock">CPU clock &amp; Wall clock</h4><p>在示例 demo 的 <em>system interfaces</em> 阶段， <em>wall clock</em>（挂钟，即现实世界的时间）显示有 <strong>149ms</strong>，但 <em>CPU clock</em>（CPU 时钟）只有 <strong>6ms</strong>。</p><ul><li>Wall clock：</ul><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/App-launch-wall-clock.jpg" alt="App-launch-wall-clock.jpg" /></p><ul><li>CPU clock：</ul><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/App-launch-CPU-clock.jpg" alt="App-launch-CPU-clock.jpg" /></p><p>这个差异来自测量机制本身的耗时，CPU clock 的数据剔除了这部分时间，因此，我们应该以调用栈中显示的 CPU clock 耗时为准。</p><h4 id="线程的优先级">线程的优先级</h4><ul><li>Priority 47 ：user interactive QoS ，主线程使用此 QoS 。<li>Priority 4 ：background QoS 。<li>… (还有一些其他的 QoS 这里没写)</ul><h4 id="线程优先级反转的问题">线程优先级反转的问题</h4><p>从下图可以看出，主线程被阻塞了（灰色），而子线程有很多任务需要运行，但是缺乏 CPU 资源（红色）。</p><p>将菜单切换到 <code class="language-plaintext highlighter-rouge">Events: Thread States</code> ，可以查看线程的状态：</p><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/App-launch-thread-states-1.jpg" alt="App-launch-thread-states-1.jpg" /></p><p>线程的状态：</p><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/App-launch-thread-states-2.jpg" alt="App-launch-thread-states-2.jpg" /></p><p>主线程的状态中有这样一行：</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>make runnable by __thread_selfid 0x12253 running on Core 1
</pre></table></code></div></div><p>说明主线程是被这个子线程设置为 runnable 的，因此，主线程的阻塞是这个子线程造成的。</p><p>子线程的信息：</p><ul><li>名称：<code class="language-plaintext highlighter-rouge">__thread_selfid</code><li>地址：<code class="language-plaintext highlighter-rouge">0x12253</code></ul><p>点击子线程，可以看到，它的 QoS 是 4 ，也就是 background QoS ：</p><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/App-launch-thread-states-3.jpg" alt="App-launch-thread-states-3.jpg" /></p><p>显然，这里存在<em>优先级反转（priority inversion）</em>的问题，也就是说，高优先级、高 QoS 的线程，被低优先级、低 QoS 的线程阻塞了。</p><h4 id="代码分析">代码分析</h4><p>在 <code class="language-plaintext highlighter-rouge">StarDataProvider</code> 类中，创建了一个串行队列，QoS 是 <code class="language-plaintext highlighter-rouge">.background</code> 。有两个加载数据的方法：</p><ul><li><code class="language-plaintext highlighter-rouge">loadDataAsync</code> ：异步地加载数据<li><code class="language-plaintext highlighter-rouge">loadDataSync</code> ：同步地加载数据</ul><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-priority-inversion-1.jpg" alt="APP-launch-priority-inversion-1" /></p><p>在 <code class="language-plaintext highlighter-rouge">AppDelegate</code> 中，调用了 <code class="language-plaintext highlighter-rouge">loadDataAsync</code> 方法异步加载数据。由于这个 APP 的需求是拿到数据后才能执行后续任务，因此又使用<strong>信号量</strong>来阻塞主线程，直到数据加载任务完成后，才继续执行后续任务：</p><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-priority-inversion-2.jpg" alt="APP-launch-priority-inversion-2" /></p><p>乍一看没问题，但是要注意，该子线程的 priority 是 4 ，如果有另一个 priority 更高（比如 20）的线程 A 在执行耗 CPU 的任务，那么会导致 priority 为 4 的线程缺乏 CPU 资源去执行任务，只能等线程 A 完成任务腾出 CPU 资源，才能继续执行。<strong>这导致了主线程要等待不相干的线程 A 的任务完成</strong>，实际上这完全是没必要的。</p><p>这里应该使用 <code class="language-plaintext highlighter-rouge">loadDataSync</code> 方法：</p><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-priority-inversion-3.jpg" alt="APP-launch-priority-inversion-3" /></p><p><strong>使用 sync 方法后，GCD 会暂时将主线程的优先级（priority=47）传播给这个子线程</strong>，主线程会等子线程完成任务后再恢复到活跃状态，不会被 priority 为 20 的线程 A 所影响，优先级反转问题迎刃而解。</p><h3 id="使用-xctest-测量启动">使用 XCTest 测量启动</h3><p>开发者可以利用 <em>Xcode 11</em> 中新增的 <code class="language-plaintext highlighter-rouge">XCTest</code> API 来测量 APP 的启动性能。只需几行代码，<em>Xcode</em> 就可以反复启动 APP（默认值是 5 次），然后给出 APP 启动的统计数据。</p><p>XCTest 会做一个<em>抛弃型的登录（throwaway launch）</em>，这将消除冷启动带来的差异。</p><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-XCTest.jpg" alt="APP-launch-XCTest" /></p><p>XCTest 的测量结果中会显示<em>平均启动时间</em>：</p><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-demo-optimize-result.jpg" alt="APP-launch-demo-optimize-result" /></p><h3 id="长期追踪启动数据">长期追踪启动数据</h3><ul><li>开发时就要关注 APP 的性能（<strong>Make performance a development-time priority</strong>）<li>为启动时间设置一个目标值，并用图表展示版本迭代过程中 APP 启动时间的走势</ul><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-plot.jpg" alt="APP-launch-plot" class="normal" width="400" /></p><h4 id="1-使用-xcode-organizer-收集启动数据">1. 使用 Xcode Organizer 收集启动数据</h4><p>在 <em>iOS 13</em> 中，对于选择加入的用户，APP 的性能指标将被收集。</p><p>然后，它们将在 24 小时内汇总，并发送给 Xcode Organizer ，开发者可以通过 <em>APP version</em> 和 <em>device version</em> 的直方图查看这些数据。</p><p><img data-proofer-ignore data-src="/images/WWDC/2019/423-Optimizing-App-Launch/APP-launch-Xcode-Organizer.jpg" alt="APP-launch-Xcode-Organizer" /></p><p>相关 <em>Session</em> ：</p><ul><li><a href="https://developer.apple.com/videos/play/wwdc2019/417/">WWDC 2019 / 417 - Improving Battery Life and Performance</a></ul><h4 id="2-使用-metrickit-收集更详细的统计数据">2. 使用 MetricKit 收集更详细的统计数据</h4><ul><li>收集自定义的能耗和性能指标<li>汇总结果每 24 小时交付一次</ul><h2 id="总结">总结</h2><ul><li>理解启动的各个阶段<li>使用工具去测量启动的性能，而不是估算<li>在开发的各个阶段都要追踪 APP 的性能</ul><h2 id="相关文章">相关文章</h2><ul><li><a href="https://xiaozhuanlan.com/topic/4690823715">https://xiaozhuanlan.com/topic/4690823715</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE/'>攻城狮</a>, <a href='/categories/wwdc/'>WWDC</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/wwdc19/" class="post-tag no-text-decoration" >WWDC19</a> <a href="/tags/ios/" class="post-tag no-text-decoration" >iOS</a> <a href="/tags/app-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="post-tag no-text-decoration" >APP 性能优化</a> <a href="/tags/app-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/" class="post-tag no-text-decoration" >APP 启动优化</a> <a href="/tags/dyld-3/" class="post-tag no-text-decoration" >dyld 3</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> <span class="text-muted small">-- Missing configuration options! --</span></div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <i class="fa-fw fas fa-link small" onclick="copyLink('', '')" data-toggle="tooltip" data-placement="top" title=""> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/App-Startup-Time-dyld/">【WWDC17】优化 APP 启动（dyld 2 -> dyld 3）</a><li><a href="/posts/forceFullDesktopBar/">在 macOS 的 Mission Control 中展示完整的桌面预览</a><li><a href="/posts/Optimizing-App-Startup-Time/">[WIP]【WWDC16】优化 App 启动（基于 dyld 2）</a><li><a href="/posts/Objective-C-Runtime-Changes-in-iOS-14/">【iOS 14】Objective-C Runtime 的优化</a><li><a href="/posts/Optimizing-App-Launch/">【WWDC19】优化 APP 启动（基于 dyld 3）</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ios/">iOS</a> <a class="post-tag" href="/tags/app-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/">APP 启动优化</a> <a class="post-tag" href="/tags/app-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">APP 性能优化</a> <a class="post-tag" href="/tags/objective-c-runtime/">Objective-C Runtime</a> <a class="post-tag" href="/tags/proxy/">Proxy</a> <a class="post-tag" href="/tags/shadowsocks/">Shadowsocks</a> <a class="post-tag" href="/tags/%E5%85%B3%E4%BA%8E%E5%86%99%E5%8D%9A%E5%AE%A2/">关于写博客</a> <a class="post-tag" href="/tags/app-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/">App 启动优化</a> <a class="post-tag" href="/tags/app-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">App 性能优化</a> <a class="post-tag" href="/tags/class-rw-ext-t/">class_rw_ext_t</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/App-Startup-Time-dyld/"><div class="card-body"> <span class="timeago small" >Jul 7<i class="unloaded">2021-07-07T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>【WWDC17】优化 APP 启动（dyld 2 -> dyld 3）</h3><div class="text-muted small"><p> 目录 前言 术语 Darwin 里的 dyld 的全称 启动时间 (Startup Time) 启动闭包 (Launch Closure) 回顾 WWDC16：优化 APP 启动的建议 减少启动阶段的任务 多使用 Swift Instruments:...</p></div></div></a></div><div class="card"> <a href="/posts/LLDB-beyond-po/"><div class="card-body"> <span class="timeago small" >Mar 2<i class="unloaded">2021-03-02T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>po、p、v 命令；LLDB 的自定义 Data Formatter；在 LLDB 中使用 Python 脚本</h3><div class="text-muted small"><p> 目录 前言 LLDB 常用命令 po、p、v LLDB 常用命令一：po po 的常见用法 po 是 expression 命令的 alias 创建自定义的 alias po 的原理 LLDB 常用命令二：p ...</p></div></div></a></div><div class="card"> <a href="/posts/Objective-C-Runtime-Changes-in-iOS-14/"><div class="card-body"> <span class="timeago small" >May 17<i class="unloaded">2021-05-17T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>【iOS 14】Objective-C Runtime 的优化</h3><div class="text-muted small"><p> 目录 前言 新特性的适配 1. 新增类型：class_rw_ext_t class_ro_t Clean memory &amp; Dirty memory class_rw_t 从 class_rw_t 中拆分出 class_rw_ext_t 实例 macOS...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Objective-C-Runtime-Changes-in-iOS-14/" class="btn btn-outline-primary" prompt="previous"><p>【iOS 14】Objective-C Runtime 的优化</p></a> <a href="/posts/App-Startup-Time-dyld/" class="btn btn-outline-primary" prompt="next"><p>【WWDC17】优化 APP 启动（dyld 2 -> dyld 3）</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://github.com/Huang-Libo">Huang Libo</a>. <span class="text-muted">-- Missing configuration options! --</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/ios/">iOS</a> <a class="post-tag" href="/tags/app-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/">APP 启动优化</a> <a class="post-tag" href="/tags/app-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">APP 性能优化</a> <a class="post-tag" href="/tags/objective-c-runtime/">Objective C Runtime</a> <a class="post-tag" href="/tags/proxy/">Proxy</a> <a class="post-tag" href="/tags/shadowsocks/">Shadowsocks</a> <a class="post-tag" href="/tags/%E5%85%B3%E4%BA%8E%E5%86%99%E5%8D%9A%E5%AE%A2/">关于写博客</a> <a class="post-tag" href="/tags/app-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/">App 启动优化</a> <a class="post-tag" href="/tags/app-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">App 性能优化</a> <a class="post-tag" href="/tags/class-rw-ext-t/">class_rw_ext_t</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://Huang-Libo.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
